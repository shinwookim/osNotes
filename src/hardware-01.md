# Hardware Interactions
# Address Protection
When a `syscall` instruction is executed or another interrupt occurs, the context switch is not performed directly. Instead, the program counter is updated with the memory address of the operating system code, read from the interrupt vector, which does. But how can we make sure that the interrupt vector is not compromised by (malicious) user programs?

The interrupt vector is protected because accessing it requires the CPU to be in kernel mode (meaning only the operating system is able to do it). When the computer first boots, the operating system code runs in kernel mode and sets the values in the interrupt vector and installs itself as the event handler. Then, the CPU drops privilege and the interrupt vector cannot be changed.

In the 1980s and 1990s, it was common for viruses to infect the master boot record which would allow it to install itself onto the interrupt table at boot. Then, the virus acting as the operating system would take-over hardware I/O in privileged mode infect any floppy disks that were inserted (to spread itself). However, in modern computers, this is very difficult to do as modifying the boot sequence or boot record is extremely difficult to do by a user-level program. Hence, this no longer is a concern to us.

# OS is Event Driven
As an aside, the operating system is slightly different than most user-level programs in that it is event-driven. Since user-level programs cannot run while the CPU is running operating system instructions, the operating system cannot just wait idle and observe what is going on in the system.

Instead, the operating system only runs when an event is generated[^ivt]. This event may be a interrupt generated by a hardware exception, a user-level software making a system call, or etc.
$$\text{System Call}\in\text{Interrupt}\in\text{Event}$$
[^ivt]: The interrupt vector acts as a link between the event the the operating system.
Other examples of event-driven programs may be a graphical user interface program. A GUI does not wait for the user to interact, but when a user clicks a button (and generates an event), it handles the event accordingly. Conversely, an example of a non-event driven program may be a prompt and wait program such as a Java program using `Scanner.nextInt()` to wait for user to input.

# Peripheral Devices
Our assumptions about the operating system is built around the idea of multiple programs running 'simultaneously'. This means that our system has sufficient memory to support loading the necessary amount of instructions this.

But a modern system has more than just CPUs and RAM. It has a variety of peripheral devices (such as a monitor, mouse, keyboard, etc.). Yet, all peripheral devices are similar in that they are input/output driven. They either go and get data (from the outside), or go and consume data (which we produce). Furthermore, all peripheral devices go through a shared channel called a **BUS**. This bus is how the CPU and I/O devices send data back and forth. For example, with a store instruction, the CPU sends data to the bus which then sends it to a USB drive. 

We will leave the details of how a bus operates for system engineers, but soon,  we will explore what role the operating system plays in communicating with I/O devices.
